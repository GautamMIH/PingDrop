<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PingDrop - Direct File Sharing with PeerJS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Tailwind's gray-50 */
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .tab-content { display: none; }
        .tab-content.active-content { display: block; }
        .file-drop-zone.dragover { border-color: #3b82f6; background-color: #eff6ff; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .active-content { animation: fadeIn 0.3s ease-out; }
        progress[value]::-webkit-progress-bar { background-color: #e5e7eb; border-radius: 0.5rem; }
        progress[value]::-webkit-progress-value { background-color: #3b82f6; border-radius: 0.5rem; transition: width 0.2s ease, background-color 0.2s ease; }
        progress[value]::-moz-progress-bar { background-color: #3b82f6; border-radius: 0.5rem; transition: width 0.2s ease, background-color 0.2s ease; }
        progress.completed::-webkit-progress-value { background-color: #22c55e; }
        progress.completed::-moz-progress-bar { background-color: #22c55e; }
        .btn i { margin-right: 0.5rem; }
        .file-item .file-progress-container { margin-top: 0.5rem; } 
        .upload-item { margin-bottom: 0.75rem; } 
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="text-gray-800">

    <header class="bg-white shadow-sm sticky top-0 z-50">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fas fa-paper-plane text-2xl text-blue-600"></i> <span class="text-2xl font-bold text-gray-800">PingDrop</span>
            </div>
            <div class="hidden md:flex space-x-6">
                <a href="#home" class="text-gray-600 hover:text-blue-600 transition duration-150">Home</a>
                <a href="#how-it-works" class="text-gray-600 hover:text-blue-600 transition duration-150">How it Works</a>
                <a href="#faq" class="text-gray-600 hover:text-blue-600 transition duration-150">FAQ</a>
            </div>
            <button id="mobileMenuButton" class="md:hidden text-gray-600 hover:text-blue-600">
                <i class="fas fa-bars text-2xl"></i>
            </button>
        </nav>
        <div id="mobileMenu" class="md:hidden hidden bg-white shadow-lg py-2">
            <a href="#home" class="block px-4 py-2 text-gray-600 hover:bg-blue-50 hover:text-blue-600 transition duration-150">Home</a>
            <a href="#how-it-works" class="block px-4 py-2 text-gray-600 hover:bg-blue-50 hover:text-blue-600 transition duration-150">How it Works</a>
            <a href="#faq" class="block px-4 py-2 text-gray-600 hover:bg-blue-50 hover:text-blue-600 transition duration-150">FAQ</a>
        </div>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <section id="home" class="text-center py-12 md:py-20 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl shadow-xl text-white">
            <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold mb-6">Share Files Directly, Peer to Peer.</h1>
            <p class="text-lg sm:text-xl text-blue-100 mb-8 max-w-2xl mx-auto">
                Securely transfer files of any size without uploading to a central server. Fast, private, and simple with PingDrop.
            </p>
            <a href="#file-sharing-area" class="btn bg-white text-blue-600 hover:bg-blue-50 font-semibold py-3 px-8 rounded-lg shadow-md transition duration-150 text-lg">
                <i class="fas fa-rocket"></i> Get Started
            </a>
        </section>

        <section id="file-sharing-area" class="mt-12 md:mt-16 bg-white p-6 sm:p-8 rounded-xl shadow-xl">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-gray-800 mb-8">
                Send or Receive Files
            </h2>
            <div class="flex border-b border-gray-200 mb-6 justify-center">
                <button class="tab-link active text-blue-600 border-b-2 border-blue-600 py-3 px-4 sm:px-6 font-medium text-sm sm:text-base focus:outline-none" onclick="openTab(event, 'send-tab')">
                    <i class="fas fa-upload mr-2"></i>Send Files
                </button>
                <button class="tab-link text-gray-500 hover:text-gray-700 py-3 px-4 sm:px-6 font-medium text-sm sm:text-base focus:outline-none" onclick="openTab(event, 'receive-tab')">
                    <i class="fas fa-download mr-2"></i>Receive Files
                </button>
            </div>

            <div id="send-tab" class="tab-content active-content">
                <div class="file-drop-zone border-2 border-dashed border-gray-300 rounded-lg p-6 sm:p-10 text-center cursor-pointer hover:border-blue-500 transition duration-150">
                    <i class="fas fa-cloud-upload-alt text-5xl text-blue-500 mb-4"></i>
                    <p class="text-gray-600 mb-2 text-lg">Drag & Drop files here or</p>
                    <input type="file" id="fileInput" multiple class="hidden">
                    <button class="btn bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg shadow transition duration-150" 
                            onclick="const fi = document.getElementById('fileInput'); if (fi) { fi.value = null; fi.click(); } event.stopPropagation();">
                        <i class="fas fa-folder-open"></i> Select Files
                    </button>
                </div>
                <div id="selected-files-list" class="mt-6 space-y-3"></div>
                <div id="share-id-container" class="mt-6 p-4 bg-gray-100 rounded-lg" style="display:none;">
                    <p class="text-gray-700 font-medium mb-2">Share this ID with your peer:</p>
                    <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2">
                        <input type="text" id="shareIdInput" readonly class="flex-grow p-3 border border-gray-300 rounded-lg bg-gray-50 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                        <button class="btn bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-4 rounded-lg shadow transition duration-150" onclick="copyShareId()">
                            <i class="fas fa-copy"></i> Copy ID
                        </button>
                    </div>
                </div>
                 <button id="startSessionBtn" class="btn bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow transition duration-150 mt-6 w-full sm:w-auto" style="display:none;">
                    <i class="fas fa-play-circle"></i> Start Sharing Session
                </button>
                
                <div id="sender-active-uploads-container" class="mt-6 space-y-3">
                </div>

                <div id="message-box-send" class="mt-4 p-3 rounded-md text-sm" style="display:none;"></div>
            </div>

            <div id="receive-tab" class="tab-content">
                <label for="senderIdInput" class="block text-gray-700 font-medium mb-2">Enter Sender's Share ID:</label>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2">
                    <input type="text" id="senderIdInput" placeholder="Paste Sender ID here..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                    <button id="connectToPeerBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-6 rounded-lg shadow transition duration-150">
                        <i class="fas fa-plug"></i> Connect to Sender
                    </button>
                </div>
                <div id="received-files-list" class="mt-6 space-y-3">
                    </div>
                <div id="download-mode-selector" class="mt-4 text-sm text-gray-600 text-center" style="display:none;">
                    <span class="mr-2 font-medium">Download Mode:</span>
                    <label class="mr-3"><input type="radio" name="downloadMode" value="parallel" checked class="mr-1 align-middle">Parallel</label>
                    <label><input type="radio" name="downloadMode" value="sequential" class="mr-1 align-middle">Sequential</label>
                </div>
                <div id="download-all-container" class="mt-4 text-center" style="display:none;"> 
                    <button id="downloadAllBtn" class="btn bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg shadow transition duration-150">
                        <i class="fas fa-cloud-download-alt"></i> Download All Available
                    </button>
                </div>
                <div id="message-box-receive" class="mt-4 p-3 rounded-md text-sm" style="display:none;"></div>
            </div>
        </section>

        <section id="how-it-works" class="mt-12 md:mt-16 py-12 bg-white rounded-xl shadow-xl">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-gray-800 mb-10">How It Works</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 px-6">
                <div class="text-center p-6 bg-gray-50 rounded-lg hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-center w-16 h-16 bg-blue-100 text-blue-600 rounded-full mx-auto mb-4 text-2xl"><i class="fas fa-mouse-pointer"></i></div>
                    <h3 class="text-xl font-medium text-gray-800 mb-2">1. Select Files</h3><p class="text-gray-600 text-sm">Sender chooses files to share.</p>
                </div>
                <div class="text-center p-6 bg-gray-50 rounded-lg hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-center w-16 h-16 bg-blue-100 text-blue-600 rounded-full mx-auto mb-4 text-2xl"><i class="fas fa-id-badge"></i></div>
                    <h3 class="text-xl font-medium text-gray-800 mb-2">2. Get Share ID</h3><p class="text-gray-600 text-sm">Sender starts a session and gets a unique Share ID.</p>
                </div>
                <div class="text-center p-6 bg-gray-50 rounded-lg hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-center w-16 h-16 bg-blue-100 text-blue-600 rounded-full mx-auto mb-4 text-2xl"><i class="fas fa-share-alt"></i></div>
                    <h3 class="text-xl font-medium text-gray-800 mb-2">3. Share ID</h3><p class="text-gray-600 text-sm">Sender shares this ID with the receiver.</p>
                </div>
                <div class="text-center p-6 bg-gray-50 rounded-lg hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-center w-16 h-16 bg-blue-100 text-blue-600 rounded-full mx-auto mb-4 text-2xl"><i class="fas fa-people-arrows"></i></div>
                    <h3 class="text-xl font-medium text-gray-800 mb-2">4. Connect & Transfer</h3><p class="text-gray-600 text-sm">Receiver uses ID to connect. Files transfer P2P.</p>
                </div>
            </div>
        </section>

        <section id="faq" class="mt-12 md:mt-16 py-12 bg-white rounded-xl shadow-xl">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-gray-800 mb-10">Frequently Asked Questions</h2>
            <div class="max-w-3xl mx-auto space-y-6 px-6">
                <div class="bg-gray-50 p-5 rounded-lg shadow-sm">
                    <h4 class="text-lg font-medium text-gray-800 mb-2">Is PingDrop secure?</h4>
                    <p class="text-gray-600 text-sm">Files are transferred directly between users' browsers using encrypted WebRTC channels (DTLS).
                        We don't store your files on any server. The connection is peer-to-peer.</p>
                </div>
                <div class="bg-gray-50 p-5 rounded-lg shadow-sm">
                    <h4 class="text-lg font-medium text-gray-800 mb-2">Is there a file size limit?</h4>
                    <p class="text-gray-600 text-sm">
                        Theoretically, there's no hard limit imposed by PingDrop itself. However, practical limits
                        can be influenced by browser capabilities, available RAM, and network stability.
                        Very large files (many GBs) might be challenging over unstable connections.
                    </p>
                </div>
                <div class="bg-gray-50 p-5 rounded-lg shadow-sm">
                    <h4 class="text-lg font-medium text-gray-800 mb-2">Do both users need to keep the browser window open?</h4>
                    <p class="text-gray-600 text-sm">
                        Yes. For a P2P transfer to occur, both the sender and the receiver must have the PingDrop
                        webpage open in their browser and maintain an active internet connection until the transfer is complete.
                    </p>
                </div>
                <div class="bg-gray-50 p-5 rounded-lg shadow-sm">
                    <h4 class="text-lg font-medium text-gray-800 mb-2">What technology does it use?</h4>
                    <p class="text-gray-600 text-sm">
                        PingDrop utilizes WebRTC (Web Real-Time Communication), a technology built into modern web browsers
                        that enables direct peer-to-peer connections for data transfer, video, and audio. PeerJS is used to simplify WebRTC implementation.
                    </p>
                </div>
            </div>
        </section>
    </main>

    <footer class="mt-16 py-8 bg-gray-800 text-gray-300 text-center">
        <p>&copy; <span id="currentYear"></span> PingDrop. All rights reserved. Powered by PeerJS.</p>
        <p class="text-sm mt-1">A demonstration of direct browser-to-browser file sharing.</p>
    </footer>

    <script>
    // --- PeerJS P2P Logic & UI Interaction Script ---

    const CHUNK_SIZE = 64 * 1024; 
    const MAX_PARALLEL_SENDER_UPLOADS = 4; 
    const FINAL_CANCEL_TIMEOUT = 3000; // ms to wait before finalizing "Cancelled" UI
    const IGNORED_CHUNK_UI_UPDATE_THROTTLE_MS = 250; // ms to throttle UI updates for ignored chunks

    // DOM Elements
    const fileInput = document.getElementById('fileInput');
    const selectedFilesList = document.getElementById('selected-files-list');
    const fileDropZone = document.querySelector('.file-drop-zone');
    const startSessionBtn = document.getElementById('startSessionBtn');
    const shareIdContainer = document.getElementById('share-id-container');
    const shareIdInput = document.getElementById('shareIdInput');
    const messageBoxSend = document.getElementById('message-box-send');
    const messageBoxReceive = document.getElementById('message-box-receive'); 
    
    const senderIdInput = document.getElementById('senderIdInput');
    const connectToPeerBtn = document.getElementById('connectToPeerBtn');
    const receivedFilesList = document.getElementById('received-files-list');
    const downloadAllContainer = document.getElementById('download-all-container');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const downloadModeSelector = document.getElementById('download-mode-selector');
    
    const senderActiveUploadsContainer = document.getElementById('sender-active-uploads-container');

    let selectedFiles = []; 
    let peer = null; 
    let currentConnection = null; 
    let fileChunksCollector = {}; 
    
    let senderFileRequestQueue = []; 
    let receiverDownloadQueue = [];
    let currentDownloadingFileReceiver = null; 

    const senderPeerJsConfig = {
        debug: 0, 
        config: { 'iceServers': [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ] }
    };
    let receiverPeerJsConfig = { 
        debug: 0, 
        config: { 'iceServers': [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ] }
    };

    // --- Utility Functions ---
    function generateShortId(length = 6) {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatSpeed(bytesPerSecond) {
        if (isNaN(bytesPerSecond) || !isFinite(bytesPerSecond) || bytesPerSecond < 0) return '0 B/s';
        if (bytesPerSecond < 1024) return `${bytesPerSecond.toFixed(0)} B/s`;
        const k = 1024;
        if (bytesPerSecond < k * k) return `${(bytesPerSecond / k).toFixed(1)} KB/s`;
        return `${(bytesPerSecond / (k * k)).toFixed(1)} MB/s`;
    }

    function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        return str.replace(/[&<>"']/g, match => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[match]);
    }

    function showMessage(tab, text, type = 'info') {
        const box = tab === 'send' ? messageBoxSend : messageBoxReceive;
        if (!box) { console.error(`showMessage: Message box for tab '${tab}' not found. Text: ${text}`); return; }
        box.textContent = text;
        box.className = 'mt-4 p-3 rounded-md text-sm'; 
        if (type === 'success') box.classList.add('bg-green-100', 'text-green-700');
        else if (type === 'error') box.classList.add('bg-red-100', 'text-red-700');
        else box.classList.add('bg-blue-100', 'text-blue-700');
        box.style.display = 'block';
        setTimeout(() => { box.style.display = 'none'; }, 7000);
    }

    const tabLinks = document.querySelectorAll('.tab-link');
    const tabContents = document.querySelectorAll('.tab-content');
    function openTab(event, tabName) {
        tabContents.forEach(c => { c.style.display = "none"; c.classList.remove("active-content"); });
        tabLinks.forEach(l => { l.classList.remove("active", "text-blue-600", "border-blue-600"); l.classList.add("text-gray-500", "hover:text-gray-700"); });
        document.getElementById(tabName).style.display = "block";
        document.getElementById(tabName).classList.add("active-content");
        event.currentTarget.classList.add("active", "text-blue-600", "border-blue-600");
        event.currentTarget.classList.remove("text-gray-500", "hover:text-gray-700");
    }
    document.addEventListener('DOMContentLoaded', () => {
        if (tabLinks.length > 0) openTab({ currentTarget: tabLinks[0] }, 'send-tab');
        document.getElementById('currentYear').textContent = new Date().getFullYear();
        const mobileMenuButton = document.getElementById('mobileMenuButton');
        const mobileMenu = document.getElementById('mobileMenu');
        if (mobileMenuButton && mobileMenu) mobileMenuButton.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));
        if(downloadAllBtn) downloadAllBtn.addEventListener('click', handleDownloadAll);
    });

    if(fileInput) fileInput.addEventListener('change', handleFileSelect);
    if(fileDropZone) {
        fileDropZone.addEventListener('click', (event) => {
            if (event.target === fileDropZone || event.target.tagName === 'P' || event.target.tagName === 'I' || event.target.classList.contains('fa-cloud-upload-alt')) {
                if (fileInput) { fileInput.value = null; fileInput.click(); }
            }
        });
        fileDropZone.addEventListener('dragover', e => { e.preventDefault(); fileDropZone.classList.add('dragover'); });
        fileDropZone.addEventListener('dragleave', () => fileDropZone.classList.remove('dragover'));
        fileDropZone.addEventListener('drop', e => {
            e.preventDefault(); fileDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFileSelect({ target: { files: e.dataTransfer.files } });
        });
    }

    function handleFileSelect(event) {
        const newFiles = Array.from(event.target.files);
        newFiles.forEach(newFile => {
            if (!selectedFiles.some(existingFile => existingFile.name === newFile.name && existingFile.size === newFile.size)) {
                selectedFiles.push(newFile);
            } else { showMessage('send', `'${escapeHTML(newFile.name)}' is already selected.`, 'info'); }
        });
        renderSelectedFiles();
        if (selectedFiles.length > 0) { if(startSessionBtn) startSessionBtn.style.display = 'inline-flex'; } 
        else { if(startSessionBtn) startSessionBtn.style.display = 'none';}
    }
    function renderSelectedFiles() {
        selectedFilesList.innerHTML = '';
        selectedFiles.forEach((file, index) => {
            const item = document.createElement('div');
            item.className = 'file-item flex justify-between items-center p-3 bg-gray-100 rounded-lg shadow-sm';
            item.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2">
                    <i class="fas fa-file-alt text-blue-500 mr-3"></i>
                    <span class="text-sm text-gray-700 truncate" title="${escapeHTML(file.name)}">${escapeHTML(file.name)}</span>
                    <span class="text-xs text-gray-500 ml-2 whitespace-nowrap">(${formatFileSize(file.size)})</span>
                </div>
                <button onclick="removeFile(${index})" title="Remove file" class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100"><i class="fas fa-times-circle text-lg"></i></button>`;
            selectedFilesList.appendChild(item);
        });
    }
    function removeFile(index) {
        selectedFiles.splice(index, 1); renderSelectedFiles();
        if (selectedFiles.length === 0) {
            if(startSessionBtn) startSessionBtn.style.display = 'none';
            if(shareIdContainer) shareIdContainer.style.display = 'none';
            if (peer && !currentConnection) showMessage('send', 'Select files to share with your ID.', 'info');
            else if (currentConnection && currentConnection.open) { showMessage('send', 'File list updated. Resending to peer.', 'info'); sendFileList(currentConnection); }
        } else if (currentConnection && currentConnection.open) { showMessage('send', 'File list updated. Resending to peer.', 'info'); sendFileList(currentConnection); }
    }

    if (startSessionBtn) {
        startSessionBtn.addEventListener('click', () => {
            if (selectedFiles.length === 0) { showMessage('send', "Please select files to share first.", 'error'); return; }
            if (peer && !peer.destroyed) { peer.destroy(); }
            peer = null; 
            const shortId = generateShortId(6); 
            showMessage('send', `Attempting to use Share ID: ${shortId}...`, 'info');
            startSessionBtn.disabled = true; startSessionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Starting...';
            peer = new Peer(shortId, senderPeerJsConfig); 
            peer.on('open', (id) => { 
                showMessage('send', `Sharing session started. Your Share ID: ${id}`, 'success');
                shareIdInput.value = id; shareIdContainer.style.display = 'block';
                startSessionBtn.disabled = false; startSessionBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Restart Session (New ID)';
                setupSenderPeerEventHandlers(peer); 
            });
            peer.on('error', (err) => {
                console.error("[SENDER] PeerJS Error during setup: ", err);
                if (err.type === 'unavailable-id') showMessage('send', `Share ID "${shortId}" was taken. Please try starting again.`, 'error');
                else if (['network', 'server-error', 'socket-error', 'socket-closed'].includes(err.type)) showMessage('send', `Network/Server error with PeerJS. Check internet and try again. (${err.type})`, 'error');
                else showMessage('send', `PeerJS Error: ${err.type} - ${err.message}`, 'error');
                startSessionBtn.disabled = false; startSessionBtn.innerHTML = '<i class="fas fa-play-circle"></i> Start Sharing Session';
                if(peer && !peer.destroyed) peer.destroy(); peer = null; shareIdContainer.style.display = 'none';
            });
        });
    }

    function setupSenderPeerEventHandlers(currentPeerInstance) {
        if (!currentPeerInstance || currentPeerInstance.destroyed) return;
        currentPeerInstance.off('connection'); currentPeerInstance.off('disconnected');
        currentPeerInstance.on('connection', (conn) => {
            showMessage('send', `Peer ${conn.peer} attempting to connect.`, 'info');
            currentConnection = conn; 
            senderFileRequestQueue = []; 
            senderActiveUploadsContainer.innerHTML = ''; 
            conn.on('open', () => { showMessage('send', `Peer ${conn.peer} connected. Sending file list.`, 'success'); sendFileList(conn); });
            conn.on('data', (data) => handleSenderData(conn, data));
            conn.on('close', () => {
                showMessage('send', `Peer ${conn.peer} disconnected.`, 'info');
                if (currentConnection && currentConnection.peer === conn.peer) currentConnection = null;
                senderActiveUploadsContainer.querySelectorAll(`.upload-item[data-conn-id="${conn.peer}"]`).forEach(el => {
                    const statusEl = el.querySelector('.upload-item-status');
                    if (statusEl && !statusEl.textContent.includes('Complete') && !statusEl.textContent.includes('Cancelled')) {
                        statusEl.innerHTML = '<span class="text-yellow-600 font-medium">Interrupted (Connection Closed)</span>'; 
                        el.querySelector('.upload-item-progressbar').value = 0; 
                    }
                });
                senderFileRequestQueue = senderFileRequestQueue.filter(req => req.conn.peer !== conn.peer);
            });
            conn.on('error', (err) => {
                showMessage('send', `Connection error with ${conn.peer}: ${err.message}`, 'error');
                if (currentConnection && currentConnection.peer === conn.peer) currentConnection = null;
                 senderActiveUploadsContainer.querySelectorAll(`.upload-item[data-conn-id="${conn.peer}"]`).forEach(el => {
                    const statusEl = el.querySelector('.upload-item-status');
                     if (statusEl) statusEl.innerHTML = '<span class="text-red-600 font-medium">Failed (Connection Error)</span>'; 
                     el.querySelector('.upload-item-progressbar').value = 0;
                });
                senderFileRequestQueue = senderFileRequestQueue.filter(req => req.conn.peer !== conn.peer);
            });
        });
        currentPeerInstance.on('disconnected', () => {
            showMessage('send', 'Disconnected from PeerJS server. You may need to restart session.', 'warning');
            senderFileRequestQueue = []; senderActiveUploadsContainer.innerHTML = '';
        });
    }

    function sendFileList(conn) {
        const fileMetadata = selectedFiles.map(file => ({ name: file.name, size: file.size, type: file.type }));
        if (conn && conn.open) { conn.send({ type: 'file-list', files: fileMetadata }); showMessage('send', 'Sent file list to peer.', 'info'); } 
        else { showMessage('send', 'Could not send file list: connection not open.', 'error'); }
    }
    
    function processSenderQueue(conn) { 
        if (!conn || !conn.open) {
            console.log(`[SENDER QUEUE DEBUG] For ${conn?.peer || 'unknown peer'}: Connection not open or invalid. Cannot process queue.`);
            return;
        }

        let activeUploadsCount = Array.from(senderActiveUploadsContainer.children)
            .filter(el => el.dataset.connId === conn.peer && el.dataset.status === "sending").length;
        
        console.log(`[SENDER QUEUE DEBUG] For ${conn.peer}: Current active uploads: ${activeUploadsCount}, Max allowed: ${MAX_PARALLEL_SENDER_UPLOADS}. Queue length for this peer: ${senderFileRequestQueue.filter(req => req.conn.peer === conn.peer).length}`);

        while (activeUploadsCount < MAX_PARALLEL_SENDER_UPLOADS && senderFileRequestQueue.some(req => req.conn.peer === conn.peer)) {
            const requestIndex = senderFileRequestQueue.findIndex(req => req.conn.peer === conn.peer);
            if (requestIndex === -1) {
                console.log(`[SENDER QUEUE DEBUG] No more requests for ${conn.peer} in the queue.`);
                break; 
            }

            const nextRequest = senderFileRequestQueue.splice(requestIndex, 1)[0];
            const escapedFileName = escapeHTML(nextRequest.file.name);
            let uploadItem = document.querySelector(`.upload-item[data-filename="${escapedFileName}"][data-conn-id="${conn.peer}"]`);
            
            if (uploadItem && (uploadItem.dataset.status === "sending" || uploadItem.dataset.status === "complete")) {
                console.warn(`[SENDER QUEUE DEBUG] File ${escapedFileName} for ${conn.peer} is already sending or complete. Skipping re-initiation.`);
                activeUploadsCount = Array.from(senderActiveUploadsContainer.children) 
                    .filter(el => el.dataset.connId === conn.peer && el.dataset.status === "sending").length; 
                continue; 
            }
            
            if (!uploadItem || ["cancelled", "error", "cancelling"].includes(uploadItem.dataset.status)) { 
                if (uploadItem) { 
                    console.log(`[SENDER QUEUE DEBUG] Re-using/resetting UI for ${escapedFileName} (previous status: ${uploadItem.dataset.status})`);
                } else { 
                    console.log(`[SENDER QUEUE DEBUG] Creating new UI for ${escapedFileName}`);
                    uploadItem = document.createElement('div');
                    senderActiveUploadsContainer.prepend(uploadItem); 
                }
                uploadItem.className = 'upload-item p-3 bg-gray-50 rounded-lg shadow-sm';
                uploadItem.dataset.filename = escapedFileName;
                uploadItem.dataset.connId = conn.peer;
                uploadItem.innerHTML = `
                    <p class="text-sm font-medium text-gray-700">Sending to ${conn.peer.slice(0,8)}...: <span class="upload-item-filename font-semibold">${escapedFileName}</span></p>
                    <progress class="upload-item-progressbar w-full h-2 rounded-lg mt-1" value="0" max="100"></progress>
                    <p class="upload-item-status text-xs text-gray-500 mt-1">
                        <span class="upload-percentage font-medium">0%</span>
                        <span class="text-gray-400"> of </span>
                        <span class="upload-total-size-text text-gray-400">${formatFileSize(nextRequest.file.size)}</span>
                        <span class="text-gray-400"> (</span><span class="upload-acknowledged-size-text text-gray-400" style="display: inline-block; min-width: 75px; text-align: right;">0 Bytes</span><span class="text-gray-400"> acknowledged)</span>
                    </p>
                `;
            }
            
            uploadItem.dataset.status = "sending"; 
            uploadItem.dataset.totalSize = nextRequest.file.size;
            
            const uploadItemProgressBar = uploadItem.querySelector('.upload-item-progressbar');
            const percentageSpan = uploadItem.querySelector('.upload-percentage');
            const acknowledgedSizeSpan = uploadItem.querySelector('.upload-acknowledged-size-text');
            const totalSizeTextSpan = uploadItem.querySelector('.upload-total-size-text');

            if (uploadItemProgressBar) { uploadItemProgressBar.value = 0; uploadItemProgressBar.classList.remove('completed');}
            if (percentageSpan) percentageSpan.textContent = '0%';
            if (acknowledgedSizeSpan) acknowledgedSizeSpan.textContent = formatFileSize(0);
            if (totalSizeTextSpan) totalSizeTextSpan.textContent = formatFileSize(nextRequest.file.size);

            console.log(`[SENDER QUEUE DEBUG] Starting sendFileInChunks for ${nextRequest.file.name} to ${conn.peer}. Active uploads will be: ${activeUploadsCount + 1}`);
            sendFileInChunks(conn, nextRequest.file); 
            activeUploadsCount++; 
        }

        if(activeUploadsCount >= MAX_PARALLEL_SENDER_UPLOADS) {
            console.log(`[SENDER QUEUE DEBUG] Reached max parallel uploads for ${conn.peer}. No more files started this cycle.`);
        } else if (!senderFileRequestQueue.some(req => req.conn.peer === conn.peer)) {
            console.log(`[SENDER QUEUE DEBUG] No more items in queue for ${conn.peer} after processing this cycle.`);
        }
    }

    function handleSenderData(conn, data) {
        console.log(`[SENDER] Received data from ${conn.peer}:`, data.type, data.fileName || '');
        if (data.type === 'request-file') {
            const fileToShare = selectedFiles.find(f => f.name === data.fileName);
            if (fileToShare) { 
                const isAlreadyInQueue = senderFileRequestQueue.some(req => req.file.name === fileToShare.name && req.conn.peer === conn.peer);
                const isAlreadySendingOrComplete = document.querySelector(`.upload-item[data-filename="${escapeHTML(data.fileName)}"][data-conn-id="${conn.peer}"][data-status="sending"]`) ||
                                                 document.querySelector(`.upload-item[data-filename="${escapeHTML(data.fileName)}"][data-conn-id="${conn.peer}"][data-status="complete"]`);

                if (!isAlreadyInQueue && !isAlreadySendingOrComplete) {
                    senderFileRequestQueue.push({ conn: conn, file: fileToShare, totalSize: fileToShare.size }); 
                    showMessage('send', `'${escapeHTML(data.fileName)}' added to send queue for ${conn.peer.slice(0,8)}.`, 'info');
                    console.log(`[SENDER] Added ${data.fileName} to queue for ${conn.peer}. Queue size for peer: ${senderFileRequestQueue.filter(req => req.conn.peer === conn.peer).length}`);
                    processSenderQueue(conn); 
                } else {
                    console.log(`[SENDER] Request for ${data.fileName} from ${conn.peer} ignored, already processing or in queue.`);
                }
            } else { 
                conn.send({ type: 'error', message: `File '${data.fileName}' not found.` }); 
                showMessage('send', `Peer requested non-existent file: '${data.fileName}'`, 'error');
            }
        } else if (data.type === 'receiver-progress') {
            const escapedFileName = escapeHTML(data.fileName);
            const uploadItem = document.querySelector(`.upload-item[data-filename="${escapedFileName}"][data-conn-id="${conn.peer}"]`);

            if (uploadItem && uploadItem.dataset.status === "sending") { 
                const totalSize = parseFloat(uploadItem.dataset.totalSize) || 0; 
                const percentage = data.percentage;
                const receivedBytes = data.receivedBytes; 

                const progressBar = uploadItem.querySelector('.upload-item-progressbar');
                const percentageSpan = uploadItem.querySelector('.upload-percentage');
                const acknowledgedSizeSpan = uploadItem.querySelector('.upload-acknowledged-size-text');

                if (progressBar) {
                    progressBar.value = percentage;
                    if (percentage === 100) progressBar.classList.add('completed');
                    else progressBar.classList.remove('completed');
                }
                if (percentageSpan) percentageSpan.textContent = `${percentage}%`;
                if (acknowledgedSizeSpan) acknowledgedSizeSpan.textContent = formatFileSize(receivedBytes); 
                
                if (percentage === 100) { 
                    const statusP = uploadItem.querySelector('.upload-item-status');
                    if(statusP) statusP.innerHTML = `<span class="text-green-600 font-medium">Complete! (${formatFileSize(totalSize)} acknowledged)</span>`;
                    uploadItem.dataset.status = "complete"; 
                    console.log(`[SENDER DEBUG] File ${escapedFileName} to ${conn.peer} marked as complete by receiver. Calling processSenderQueue.`);
                    setTimeout(() => { uploadItem.remove(); }, 5000); 
                    processSenderQueue(conn);    
                }
            }
        } else if (data.type === 'cancel-transfer') {
            const escapedFileName = escapeHTML(data.fileName);
            console.log(`[SENDER DEBUG] Received cancel-transfer for ${escapedFileName} from ${conn.peer}.`);
            
            const uploadItem = document.querySelector(`.upload-item[data-filename="${escapedFileName}"][data-conn-id="${conn.peer}"]`);
            if (uploadItem) {
                const statusP = uploadItem.querySelector('.upload-item-status');
                if (statusP && uploadItem.dataset.status !== "cancelled") { 
                    statusP.innerHTML = `<span class="text-yellow-600 font-medium"><i class="fas fa-spinner fa-spin mr-1"></i>Cancelling...</span>`;
                }
                uploadItem.dataset.status = "cancelling"; 

                setTimeout(() => {
                    if (uploadItem.dataset.status === "cancelling") { 
                         uploadItem.dataset.status = "cancelled";
                         if (statusP) statusP.innerHTML = '<span class="text-yellow-600 font-medium">Cancelled by receiver</span>';
                         console.log(`[SENDER DEBUG] Status for ${escapedFileName} set to 'cancelled'.`);
                         setTimeout(() => { 
                            if(uploadItem.dataset.status === "cancelled") uploadItem.remove(); 
                        }, 4000); 
                    }
                }, 1000); 
            }
            senderFileRequestQueue = senderFileRequestQueue.filter(req => !(req.file.name === data.fileName && req.conn.peer === conn.peer));
            console.log(`[SENDER DEBUG] Processed cancel-transfer for ${data.fileName}. Calling processSenderQueue for ${conn.peer}.`);
            processSenderQueue(conn); 
        }
    }

    async function sendFileInChunks(conn, file) {
        console.log(`[SENDER sendFileInChunks] Initiating for file: ${file.name} to ${conn.peer}`);
        const reader = new FileReader();
        let offset = 0;
        const totalFileSize = file.size;
        let chunkIndex = 0;
        const totalChunks = Math.ceil(totalFileSize / CHUNK_SIZE); 
        const escapedFileName = escapeHTML(file.name);
        
        const uploadItem = document.querySelector(`.upload-item[data-filename="${escapedFileName}"][data-conn-id="${conn.peer}"]`);
        if (!uploadItem) {
             console.error(`[SENDER sendFileInChunks] Critical: Upload item for ${file.name} not found at initiation. Aborting send.`);
            return;
        }
        if (uploadItem.dataset.status !== "sending") {
             console.log(`[SENDER sendFileInChunks] Initial status for ${file.name} is not 'sending' (${uploadItem.dataset.status}). Not starting.`);
            return;
        }

        function readNextChunk() {
            if (uploadItem.dataset.status !== "sending") {
                console.log(`[SENDER sendFileInChunks - readNextChunk] HALTED for ${file.name}. Status: ${uploadItem.dataset.status}.`);
                reader.onload = null; 
                reader.onerror = null;
                return; 
            }
            if (offset >= totalFileSize || !conn.open ) {
                console.log(`[SENDER sendFileInChunks - readNextChunk] Conditions met for halting/completion for ${file.name}. Offset: ${offset}, ConnOpen: ${conn.open}.`);
                if (offset >= totalFileSize && conn.open && uploadItem.dataset.status === "sending") {
                    if (conn.open) conn.send({ type: 'transfer-end', name: file.name, success: true });
                }
                return; 
            }
            const slice = file.slice(offset, offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        }

        reader.onload = (event) => {
            if (uploadItem.dataset.status !== "sending") {
                console.log(`[SENDER sendFileInChunks - onload] HALTED before send for ${file.name}. Status: ${uploadItem.dataset.status}.`);
                return; 
            }
            if (!conn.open) {
                 console.log(`[SENDER sendFileInChunks - onload] Connection closed for ${file.name} before send.`);
                 return;
            }

            try {
                const chunkData = event.target.result;
                const isLastChunk = (offset + chunkData.byteLength >= totalFileSize);
                
                conn.send({
                    type: 'file-chunk', 
                    name: file.name,
                    chunk: chunkData, 
                    chunkIndex: chunkIndex, 
                    totalChunks: totalChunks, 
                    isLast: isLastChunk,
                    fileType: file.type,
                    fileSize: totalFileSize
                });
                offset += chunkData.byteLength;
                chunkIndex++;

                if (offset < totalFileSize) {
                    if (uploadItem.dataset.status === "sending") {
                        readNextChunk(); 
                    } else {
                         console.log(`[SENDER sendFileInChunks - onload] Status changed for ${file.name} after send, before next read. Halting further reads.`);
                    }
                } else { 
                    console.log(`[SENDER sendFileInChunks] Finished sending all chunks of ${escapedFileName} to ${conn.peer}.`);
                    if (conn.open) conn.send({ type: 'transfer-end', name: file.name, success: true });
                }
            } catch (error) {
                console.error(`[SENDER sendFileInChunks] Error sending chunk for ${escapedFileName}:`, error);
                if(uploadItem && uploadItem.dataset.status === "sending") uploadItem.dataset.status = "error"; 
                const statusP = uploadItem?.querySelector('.upload-item-status');
                if(statusP) statusP.innerHTML = `<span class="text-red-600 font-medium">Error Sending Chunk</span>`;
                if (conn.open) conn.send({ type: 'transfer-end', name: file.name, success: false, error: `Error sending chunk for ${escapedFileName}` });
                processSenderQueue(conn); 
            }
        };
        reader.onerror = (error) => {
            console.error(`[SENDER sendFileInChunks] FileReader error for ${escapedFileName}:`, error);
            if(uploadItem && uploadItem.dataset.status === "sending") uploadItem.dataset.status = "error";
            const statusP = uploadItem?.querySelector('.upload-item-status');
            if(statusP) statusP.innerHTML = `<span class="text-red-600 font-medium">File Read Error</span>`;
            if (conn.open) conn.send({ type: 'transfer-end', name: file.name, success: false, error: `File read error on sender side for ${escapedFileName}.` });
            processSenderQueue(conn);
        };
        
        if (uploadItem.dataset.status === "sending") {
            readNextChunk();
        } else {
            console.log(`[SENDER sendFileInChunks] Initial status for ${file.name} is not 'sending' (${uploadItem.dataset.status}). Not starting readNextChunk.`);
        }
    }


    function copyShareId() {
        if (!shareIdInput.value) return;
        shareIdInput.select();
        shareIdInput.setSelectionRange(0, 99999);
        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareIdInput.value)
                    .then(() => showMessage('send', 'Share ID copied to clipboard!', 'success'))
                    .catch(() => { if(!document.execCommand('copy')) throw Error('Fallback copy failed'); showMessage('send', 'Share ID copied (fallback)!', 'success'); });
            } else if (document.execCommand('copy')) {
                 showMessage('send', 'Share ID copied (fallback)!', 'success');
            } else { throw Error('Copy not supported'); }
        } catch (err) {
            showMessage('send', 'Failed to copy ID. Please copy manually.', 'error');
        }
        window.getSelection().removeAllRanges();
    }

    if (connectToPeerBtn) {
        connectToPeerBtn.addEventListener('click', () => {
            const remoteId = senderIdInput.value.trim();
            if (!remoteId) { showMessage('receive', "Please enter the Sender's Share ID.", 'error'); return; }
            if (peer) { peer.destroy(); }
            
            receiverPeerJsConfig.debug = 0; 
            peer = new Peer(undefined, receiverPeerJsConfig); 

            connectToPeerBtn.disabled = true;
            showMessage('receive', `Initializing connection to ${remoteId}...`, 'info');

            peer.on('open', () => {
                currentConnection = peer.connect(remoteId, { reliable: true });
                currentConnection.on('open', () => {
                    showMessage('receive', `Connected to sender ${remoteId}! Waiting for file list...`, 'success');
                    connectToPeerBtn.disabled = false;
                    connectToPeerBtn.innerHTML = '<i class="fas fa-check-circle"></i> Connected';
                });
                currentConnection.on('data', (data) => handleReceiverData(data));
                currentConnection.on('close', () => {
                    showMessage('receive', 'Connection to sender closed.', 'info');
                    resetReceiverUI();
                });
                currentConnection.on('error', (err) => {
                    console.error("[RECEIVER] DataConnection error:", err);
                    showMessage('receive', `Connection error: ${err.message}`, 'error');
                    resetReceiverUI();
                });
            });
            peer.on('error', (err) => {
                console.error("[RECEIVER] Receiver's Peer object error:", err);
                showMessage('receive', `PeerJS Error (Receiver): ${err.type} - ${err.message}`, 'error');
                resetReceiverUI();
            });
        });
    }
    
    function resetReceiverUI() {
        if (connectToPeerBtn) {
            connectToPeerBtn.disabled = false;
            connectToPeerBtn.innerHTML = '<i class="fas fa-plug"></i> Connect to Sender';
        }
        if (receivedFilesList) receivedFilesList.innerHTML = '';
        if (downloadAllContainer) downloadAllContainer.style.display = 'none'; 
        if (downloadModeSelector) downloadModeSelector.style.display = 'none';
        document.querySelectorAll('.file-progress-container').forEach(el => el.style.display = 'none');

        if (currentConnection) { currentConnection.close(); currentConnection = null; }
        if(peer && !peer.destroyed) { peer.destroy(); peer = null; }
        receiverDownloadQueue = [];
        currentDownloadingFileReceiver = null;
        fileChunksCollector = {}; 
    }

    function handleReceiverData(data) {
        console.log(`[RECEIVER] Received data:`, data.type, data.fileName || data.name || '');
        if (data.type === 'file-list') {
            receivedFilesList.innerHTML = ''; 
            receiverDownloadQueue = []; 
            currentDownloadingFileReceiver = null;
            fileChunksCollector = {}; 

            if (data.files && data.files.length > 0) {
                data.files.forEach(file => {
                    const escapedFileName = escapeHTML(file.name);
                    const item = document.createElement('div');
                    item.className = 'file-item p-3 bg-gray-100 rounded-lg shadow-sm'; 
                    item.dataset.filename = escapedFileName; 
                    item.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center overflow-hidden mr-2">
                                <i class="fas fa-file-alt text-blue-500 mr-3"></i>
                                <span class="text-sm text-gray-700 truncate" title="${escapedFileName}">${escapedFileName}</span>
                                <span class="text-xs text-gray-500 ml-2 whitespace-nowrap">(${formatFileSize(file.size)})</span>
                            </div>
                            <div class="flex items-center"> <button class="download-btn btn bg-green-500 hover:bg-green-600 text-white font-medium py-1 px-3 rounded-lg shadow text-xs" 
                                        data-filename="${escapedFileName}">
                                    <i class="fas fa-download"></i> Download
                                </button>
                                <button class="cancel-btn btn bg-red-500 hover:bg-red-600 text-white font-medium py-1 px-3 rounded-lg shadow text-xs ml-2" 
                                        data-filename="${escapedFileName}" style="display:none;">
                                    <i class="fas fa-times-circle"></i> Cancel
                                </button>
                            </div>
                        </div>
                        <div class="file-progress-container mt-2" style="display:none;">
                            <progress class="file-progress-bar w-full h-2 rounded-lg" value="0" max="100"></progress>
                            <p class="file-status-text text-xs text-gray-500 mt-1">
                                <span class="progress-percentage font-medium">0%</span>
                                <span class="text-gray-400"> of </span>
                                <span class="total-size-text text-gray-400">${formatFileSize(file.size)}</span>
                                <span class="text-gray-400"> (</span><span class="received-size-text text-gray-400" style="display: inline-block; min-width: 75px; text-align: right;">0 Bytes</span><span class="text-gray-400"> received)</span>
                                <span class="text-gray-400"> - </span>
                                <span class="speed-text font-medium">Waiting...</span>
                            </p>
                        </div>`;
                    receivedFilesList.appendChild(item);
                    item.querySelector('.download-btn').addEventListener('click', function() {
                        requestFileFromServer(this.dataset.filename);
                    });
                    item.querySelector('.cancel-btn').addEventListener('click', function() {
                        handleCancelDownload(this.dataset.filename);
                    });
                });
                if (downloadModeSelector) downloadModeSelector.style.display = 'block';
                if (downloadAllContainer) downloadAllContainer.style.display = 'block';
            } else { 
                if (downloadModeSelector) downloadModeSelector.style.display = 'none';
                if (downloadAllContainer) downloadAllContainer.style.display = 'none';
                showMessage('receive', 'Sender has no files to share at the moment.', 'info');
            }
        } else if (data.type === 'file-chunk') { 
            processFileChunk(data); 
        } else if (data.type === 'transfer-end') { 
            if (!data.success) {
                showMessage('receive', `Sender reported error during transfer of ${escapeHTML(data.name)}: ${escapeHTML(data.error) || 'Unknown error'}`, 'error');
                const fileData = fileChunksCollector[data.name];
                if (fileData) fileData.cancelled = true; 

                const fileItemElement = document.querySelector(`.file-item[data-filename="${escapeHTML(data.name)}"]`);
                if (fileItemElement) {
                    const statusP = fileItemElement.querySelector('.file-status-text');
                    if (statusP) statusP.innerHTML = `<span class="text-red-500 font-medium">Error from Sender</span>`;
                    const downloadButton = fileItemElement.querySelector('.download-btn');
                    if (downloadButton) { downloadButton.disabled = false; downloadButton.style.display = 'inline-flex';}
                    const cancelButton = fileItemElement.querySelector('.cancel-btn');
                    if (cancelButton) cancelButton.style.display = 'none';
                }
                if (data.name === currentDownloadingFileReceiver) { 
                    currentDownloadingFileReceiver = null;
                }
                processReceiverDownloadQueue(); 
            } else {
                console.log(`[RECEIVER DEBUG] Sender confirmed end of transfer for ${data.name}. Local processing will finalize.`);
                 const fileData = fileChunksCollector[data.name];
                if (fileData && !fileData.completed && !fileData.cancelled) {
                    fileData.senderFinishedSending = true; 
                    if (fileData.receivedSize >= fileData.totalSize && fileData.totalSize > 0) {
                        console.log(`[RECEIVER DEBUG] Sender finished, and all bytes seem received for ${data.name}. Triggering final check via dummy processFileChunk.`);
                        processFileChunk({ 
                            name: data.name, 
                            isLast: true, 
                            totalChunks: fileData.totalChunksCount || Math.ceil(fileData.totalSize / CHUNK_SIZE), 
                            chunkIndex: (fileData.totalChunksCount || Math.ceil(fileData.totalSize / CHUNK_SIZE)) -1,
                            fileSize: fileData.totalSize, 
                            fileType: fileData.fileType
                        });
                    }
                }
            }
        }
        else if (data.type === 'error') { 
            showMessage('receive', `Error from sender: ${escapeHTML(data.message)}`, 'error');
        }
    }
    
    function handleDownloadAll() {
        console.log("[RECEIVER] handleDownloadAll clicked.");
        const fileItems = receivedFilesList.querySelectorAll('.file-item');
        if (fileItems.length === 0) {
            showMessage('receive', 'No files available to download.', 'info');
            return;
        }
        
        const downloadMode = document.querySelector('input[name="downloadMode"]:checked').value;
        showMessage('receive', `Starting to download all ${fileItems.length} files (${downloadMode} mode)...`, 'info');

        receiverDownloadQueue = []; 

        fileItems.forEach(item => {
            const fileName = item.dataset.filename;
            const fileData = fileChunksCollector[fileName];
            const downloadButton = item.querySelector('.download-btn');
            if (fileName && (!fileData || (!fileData.completed && !fileData.cancelled)) && (downloadButton.style.display !== 'none' && !downloadButton.disabled) ) {
                 receiverDownloadQueue.push(fileName);
            }
        });
        console.log(`[RECEIVER] Download All: Initial queue:`, [...receiverDownloadQueue]);

        if (downloadMode === 'parallel') {
            const limit = MAX_PARALLEL_SENDER_UPLOADS; 
            let requestedCount = 0;
            for(let i = 0; i < receiverDownloadQueue.length && requestedCount < limit; i++) {
                const fileNameToRequest = receiverDownloadQueue[i]; 
                const fileItemElement = document.querySelector(`.file-item[data-filename="${escapeHTML(fileNameToRequest)}"]`);
                const existingDownloadButton = fileItemElement?.querySelector('.download-btn');
                if (fileItemElement && existingDownloadButton && (existingDownloadButton.style.display === 'none' || existingDownloadButton.disabled)) {
                    console.log(`[RECEIVER] Download All: ${fileNameToRequest} seems already active, skipping initial request.`);
                    continue;
                }
                requestFileFromServer(fileNameToRequest);
                requestedCount++;
            }
            receiverDownloadQueue.splice(0, requestedCount);
            console.log(`[RECEIVER] Download All: Requested ${requestedCount} files. Remaining in queue: ${receiverDownloadQueue.length}`);

        } else { 
            processReceiverDownloadQueue(); 
        }

        if(downloadAllBtn) downloadAllBtn.disabled = true; 
        setTimeout(() => { if(downloadAllBtn) downloadAllBtn.disabled = false; }, 5000); 
    }

    function processReceiverDownloadQueue() { 
        const downloadMode = document.querySelector('input[name="downloadMode"]:checked')?.value || 'parallel';
        console.log(`[RECEIVER QUEUE DEBUG] processReceiverDownloadQueue called. Mode: ${downloadMode}. Queue length: ${receiverDownloadQueue.length}. Current sequential: ${currentDownloadingFileReceiver}`);

        if (downloadMode === 'sequential') {
            if (currentDownloadingFileReceiver === null && receiverDownloadQueue.length > 0) {
                const nextFileToDownload = receiverDownloadQueue.shift();
                console.log(`[RECEIVER QUEUE DEBUG - Sequential] Starting next: ${nextFileToDownload}`);
                currentDownloadingFileReceiver = nextFileToDownload;
                requestFileFromServer(nextFileToDownload);
            } else if (receiverDownloadQueue.length === 0 && currentDownloadingFileReceiver === null) {
                console.log('[RECEIVER QUEUE DEBUG - Sequential] All sequential downloads processed.');
            }
        } else { 
            let activeReceiverDownloads = 0;
            document.querySelectorAll('#received-files-list .file-item').forEach(item => {
                const progressContainer = item.querySelector('.file-progress-container');
                const downloadButton = item.querySelector('.download-btn');
                if (progressContainer && progressContainer.style.display === 'block' && 
                    (downloadButton.style.display === 'none' || downloadButton.disabled)) {
                    const fileName = item.dataset.filename;
                    if (fileChunksCollector[fileName] && !fileChunksCollector[fileName].completed && !fileChunksCollector[fileName].cancelled) {
                        activeReceiverDownloads++;
                    }
                }
            });

            console.log(`[RECEIVER QUEUE DEBUG - Parallel] Active downloads: ${activeReceiverDownloads}, Max allowed: ${MAX_PARALLEL_SENDER_UPLOADS}, Queue: ${receiverDownloadQueue.length}`);
            
            while(activeReceiverDownloads < MAX_PARALLEL_SENDER_UPLOADS && receiverDownloadQueue.length > 0) {
                const fileNameToRequest = receiverDownloadQueue.shift(); 
                if (fileNameToRequest) {
                    console.log(`[RECEIVER QUEUE DEBUG - Parallel] Attempting to start next from queue: ${fileNameToRequest}`);
                    requestFileFromServer(fileNameToRequest); 
                    activeReceiverDownloads++; 
                } else {
                    break; 
                }
            }
             if (receiverDownloadQueue.length === 0 && activeReceiverDownloads === 0) {
                console.log('[RECEIVER QUEUE DEBUG - Parallel] All parallel downloads processed or initiated.');
            }
        }
    }

    function requestFileFromServer(fileName) {
        console.log(`[RECEIVER requestFileFromServer] Called for: ${fileName}`);
        const fileItemElement = document.querySelector(`.file-item[data-filename="${escapeHTML(fileName)}"]`);
         if (!fileItemElement) {
            console.error(`[RECEIVER requestFileFromServer] Could not find file item for ${fileName}`);
            if (fileName === currentDownloadingFileReceiver) { 
                currentDownloadingFileReceiver = null;
                processReceiverDownloadQueue();
            }
            return;
        }

        const downloadButton = fileItemElement.querySelector('.download-btn');
        const cancelButton = fileItemElement.querySelector('.cancel-btn'); 
        const progressContainer = fileItemElement.querySelector('.file-progress-container');
        const progressBar = fileItemElement.querySelector('.file-progress-bar');
        
        const progressPercentageSpan = fileItemElement.querySelector('.progress-percentage');
        const receivedSizeSpan = fileItemElement.querySelector('.received-size-text');
        const speedSpan = fileItemElement.querySelector('.speed-text');
        const totalSizeTextSpan = fileItemElement.querySelector('.total-size-text');

        if (currentConnection && currentConnection.open) {
            if (fileChunksCollector[fileName] && !fileChunksCollector[fileName].completed && !fileChunksCollector[fileName].cancelled && 
                progressContainer.style.display === 'block' && (downloadButton.style.display === 'none' || downloadButton.disabled)) {
                 console.log(`[RECEIVER requestFileFromServer] Download for '${escapeHTML(fileName)}' is already in progress. Not re-requesting.`);
                 return;
            }

            console.log(`[RECEIVER requestFileFromServer] Proceeding to request ${fileName}`);
            if (progressContainer) progressContainer.style.display = 'block';
            if (progressBar) { progressBar.value = 0; progressBar.classList.remove('completed'); }
            if (progressPercentageSpan) progressPercentageSpan.textContent = '0%';
            
            const fileItemTotalSizeText = fileItemElement.querySelector('.text-xs.text-gray-500.ml-2.whitespace-nowrap')?.textContent.match(/\(([^)]+)\)/)?.[1];
            if(totalSizeTextSpan && fileItemTotalSizeText) totalSizeTextSpan.textContent = fileItemTotalSizeText;
            else if (totalSizeTextSpan) totalSizeTextSpan.textContent = "N/A";

            if (receivedSizeSpan) receivedSizeSpan.textContent = '0 Bytes'; 
            if (speedSpan) speedSpan.textContent = 'Starting...';
            
            if (downloadButton) {downloadButton.style.display = 'none'; downloadButton.disabled = true;}
            if (cancelButton) cancelButton.style.display = 'inline-flex'; 
            
            fileChunksCollector[fileName] = { 
                chunks: [], 
                receivedSize: 0, 
                totalSize: 0, 
                totalChunksCount: 0, 
                fileType: '', 
                completed: false, 
                cancelled: false, 
                senderFinishedSending: false,
                ignoredChunksCount: 0, 
                finalCancelTimer: null, 
                lastSpeedCalcTime: Date.now(), 
                lastSpeedCalcBytes: 0,
                lastReportedPercentage: 0,
                initialRequestTime: Date.now(),
                receivedSizeAtCancellationPoint: 0, 
                totalChunksAtCancellationPoint: 0,
                lastIgnoredChunkUIUpdateTime: 0, // For throttling ignored chunk UI updates
            };
            
            console.log(`[RECEIVER requestFileFromServer] Sending 'request-file' message for: ${fileName}`);
            currentConnection.send({ type: 'request-file', fileName: fileName });

        } else { 
            console.error(`[RECEIVER requestFileFromServer] Not connected to sender. Cannot request ${fileName}.`);
            showMessage('receive', 'Not connected to sender. Please connect first.', 'error');
             if (fileName === currentDownloadingFileReceiver) { 
                currentDownloadingFileReceiver = null;
            }
            processReceiverDownloadQueue(); 
         }
    }
    
    function getRemainingChunksForDisplay(fileData) {
        const totalChunksKnownAtCancel = fileData.totalChunksAtCancellationPoint; 
        const receivedChunksAtCancel = Math.ceil((fileData.receivedSizeAtCancellationPoint || 0) / CHUNK_SIZE);

        let effectiveTotalChunks = totalChunksKnownAtCancel;
        if (effectiveTotalChunks === 0 || effectiveTotalChunks === '?') {
            effectiveTotalChunks = fileData.totalChunksCount > 0 ? fileData.totalChunksCount :
                                  (fileData.totalSize > 0 ? Math.ceil(fileData.totalSize / CHUNK_SIZE) : 0);
        }

        if (effectiveTotalChunks === 0 || effectiveTotalChunks === '?') {
            return '?'; 
        }
        
        return Math.max(0, effectiveTotalChunks - receivedChunksAtCancel);
    }

    function handleCancelDownload(fileName) {
        const escapedFileName = escapeHTML(fileName);
        console.log(`[RECEIVER DEBUG] handleCancelDownload initiated for ${escapedFileName}`);
        
        const fileItemElement = document.querySelector(`.file-item[data-filename="${escapedFileName}"]`);
        const fileData = fileChunksCollector[escapedFileName];

        if (fileData && fileData.finalCancelTimer) {
            clearTimeout(fileData.finalCancelTimer); 
            fileData.finalCancelTimer = null;
        }
        
        if (fileItemElement) {
            const statusP = fileItemElement.querySelector('.file-status-text');
            if (statusP) { 
                statusP.innerHTML = `<span class="text-yellow-600 font-medium"><i class="fas fa-spinner fa-spin mr-1"></i>Cancelling...</span>`;
            }
            const cancelButton = fileItemElement.querySelector('.cancel-btn');
            if (cancelButton) cancelButton.style.display = 'none'; 
        }

        if (fileData) {
            console.log(`[RECEIVER DEBUG] Marking ${escapedFileName} as cancelled in collector.`);
            fileData.cancelled = true;
            fileData.receivedSizeAtCancellationPoint = fileData.receivedSize;
            fileData.totalChunksAtCancellationPoint = fileData.totalChunksCount > 0 ? fileData.totalChunksCount :
                                                      (fileData.totalSize > 0 ? Math.ceil(fileData.totalSize / CHUNK_SIZE) : 0);
            
            fileData.finalCancelTimer = setTimeout(() => {
                if (fileData.cancelled && fileItemElement) { 
                    const currentStatusP = fileItemElement.querySelector('.file-status-text');
                    if (currentStatusP) {
                        const finalRemainingChunksStr = getRemainingChunksForDisplay(fileData);
                        const currentText = currentStatusP.textContent || "";
                        if (currentText.includes("Ignored") || currentText.includes("Cancelling") || currentText.includes("Waiting") || currentText.includes("Starting") || currentText.includes("0%")) {
                            currentStatusP.innerHTML = `<span class="text-red-500 font-medium">Cancelled by User (Ignored ${fileData.ignoredChunksCount} / ${finalRemainingChunksStr} chunks)</span>`;
                        } else if (!currentText.includes("Downloaded") && !currentText.includes("Cancelled by User")) {
                            currentStatusP.innerHTML = `<span class="text-red-500 font-medium">Cancelled by User</span>`;
                        }
                    }
                    const downloadButton = fileItemElement.querySelector('.download-btn');
                    if (downloadButton) {
                        downloadButton.style.display = 'inline-flex';
                        downloadButton.disabled = false;
                    }
                     const progressBar = fileItemElement.querySelector('.file-progress-bar');
                    if(progressBar) progressBar.value = 0;
                }
            }, FINAL_CANCEL_TIMEOUT);

        } else { 
             if (fileItemElement) {
                const statusP = fileItemElement.querySelector('.file-status-text');
                if (statusP) statusP.innerHTML = `<span class="text-red-500 font-medium">Cancelled by User</span>`;
                const downloadButton = fileItemElement.querySelector('.download-btn');
                if (downloadButton) {
                    downloadButton.style.display = 'inline-flex';
                    downloadButton.disabled = false;
                }
             }
        }

        if (currentConnection && currentConnection.open) {
            console.log(`[RECEIVER DEBUG] Sending 'cancel-transfer' message for ${escapedFileName} to sender.`);
            currentConnection.send({ type: 'cancel-transfer', fileName: fileName });
        }
        
        if (fileName === currentDownloadingFileReceiver) { 
            console.log(`[RECEIVER DEBUG] ${fileName} was current sequential download. Resetting currentDownloadingFileReceiver.`);
            currentDownloadingFileReceiver = null;
        }
        console.log(`[RECEIVER DEBUG] Calling processReceiverDownloadQueue after cancelling ${fileName}.`);
        processReceiverDownloadQueue(); 
    }

    function processFileChunk(data) {
        const { name, chunk, chunkIndex, totalChunks, isLast, fileType, fileSize } = data;
        const escapedFileName = escapeHTML(name);
        const fileData = fileChunksCollector[name];

        if (!fileData) { 
             console.warn(`[RECEIVER DEBUG] processFileChunk: Collector for ${name} not found. Ignored.`);
             return; 
        }

        if (fileData.totalSize === 0 && fileSize > 0) {
            fileData.totalSize = fileSize;
        }
        if ((!fileData.totalChunksCount || fileData.totalChunksCount === 0) && totalChunks > 0) {
            fileData.totalChunksCount = totalChunks;
        }

        if (fileData.cancelled) {
            fileData.ignoredChunksCount = (fileData.ignoredChunksCount || 0) + 1;
            const now = Date.now();

            if (fileData.ignoredChunksCount === 1 || now - (fileData.lastIgnoredChunkUIUpdateTime || 0) > IGNORED_CHUNK_UI_UPDATE_THROTTLE_MS ) {
                const fileItemElement = document.querySelector(`.file-item[data-filename="${escapedFileName}"]`);
                if (fileItemElement) {
                    const statusP = fileItemElement.querySelector('.file-status-text');
                    if (statusP) {
                        const remainingChunksStr = getRemainingChunksForDisplay(fileData);
                        statusP.innerHTML = `<span class="text-yellow-600 font-medium">Cancelled. Ignored ${fileData.ignoredChunksCount} / ${remainingChunksStr} chunks.</span>`;
                    }
                }
                fileData.lastIgnoredChunkUIUpdateTime = now;
            }

            if (fileData.finalCancelTimer) clearTimeout(fileData.finalCancelTimer);
            fileData.finalCancelTimer = setTimeout(() => {
                const fileItemElement = document.querySelector(`.file-item[data-filename="${escapedFileName}"]`);
                if (fileData.cancelled && fileItemElement) { 
                    const currentStatusP = fileItemElement.querySelector('.file-status-text');
                     if (currentStatusP) {
                        const finalRemainingChunksStr = getRemainingChunksForDisplay(fileData);
                        const currentText = currentStatusP.textContent || "";
                        if (currentText.includes("Ignored") || currentText.includes("Cancelling") || currentText.includes("Waiting") || currentText.includes("Starting") || currentText.includes("0%")) {
                            currentStatusP.innerHTML = `<span class="text-red-500 font-medium">Cancelled by User (Ignored ${fileData.ignoredChunksCount} / ${finalRemainingChunksStr} chunks)</span>`;
                        } else if (!currentText.includes("Downloaded") && !currentText.includes("Cancelled by User")) {
                            currentStatusP.innerHTML = `<span class="text-red-500 font-medium">Cancelled by User</span>`;
                        }
                    }
                    const downloadButton = fileItemElement.querySelector('.download-btn');
                    if (downloadButton) {
                        downloadButton.style.display = 'inline-flex';
                        downloadButton.disabled = false;
                    }
                    const progressBar = fileItemElement.querySelector('.file-progress-bar');
                    if(progressBar) progressBar.value = 0;
                }
            }, FINAL_CANCEL_TIMEOUT);

            console.log(`[RECEIVER processFileChunk DEBUG] Ignoring chunk ${chunkIndex !== undefined ? chunkIndex : 'N/A'} for cancelled file: ${name}. Total ignored: ${fileData.ignoredChunksCount}`);
            return; 
        }

        const fileItemElement = document.querySelector(`.file-item[data-filename="${escapedFileName}"]`);
        if (!fileItemElement) { 
            console.warn(`[RECEIVER DEBUG] processFileChunk: No file item for ${escapedFileName}. Ignored.`);
            return; 
        }
    
        const progressBar = fileItemElement.querySelector('.file-progress-bar');
        const progressPercentageSpan = fileItemElement.querySelector('.progress-percentage');
        const totalSizeTextSpan = fileItemElement.querySelector('.total-size-text');
        const receivedSizeSpan = fileItemElement.querySelector('.received-size-text');
        const speedSpan = fileItemElement.querySelector('.speed-text');
    
        if (fileData.completed) { 
            console.log(`[RECEIVER DEBUG] File ${name} already completed. Ignoring chunk ${chunkIndex}.`);
            return;
        }
    
        if(fileData.totalSize === 0 && fileSize > 0) {
            fileData.totalSize = fileSize;
            if (totalSizeTextSpan) totalSizeTextSpan.textContent = formatFileSize(fileSize);
        }
        if ((!fileData.totalChunksCount || fileData.totalChunksCount === 0) && totalChunks > 0) {
             fileData.totalChunksCount = totalChunks;
        }
        if(!fileData.fileType && fileType) fileData.fileType = fileType;
        
        if (chunk && chunkIndex !== undefined) { 
            fileData.chunks[chunkIndex] = chunk; 
            fileData.receivedSize += chunk.byteLength;
        } else if (!isLast && chunkIndex !== undefined) { 
            console.warn(`[RECEIVER DEBUG] Received chunk message for ${name} (index ${chunkIndex}) without chunk data and not isLast.`);
        } else if (!isLast && chunkIndex === undefined) { 
             console.warn(`[RECEIVER DEBUG] Received incomplete chunk message for ${name}. Ignoring.`);
             return;
        }
    
        let overallProgress = 0;
        if (fileData.totalSize > 0) {
            overallProgress = Math.min(100, Math.round((fileData.receivedSize / fileData.totalSize) * 100));
        } else if (fileData.totalChunksCount > 0 && chunkIndex !== undefined) { 
             overallProgress = Math.min(100, Math.round(((chunkIndex + 1) / fileData.totalChunksCount) * 100));
        }
    
        if (progressBar) progressBar.value = overallProgress;
        if (progressPercentageSpan) progressPercentageSpan.textContent = `${overallProgress}%`;
    
        const currentTime = Date.now();
        const timeElapsedSeconds = (currentTime - fileData.lastSpeedCalcTime) / 1000;
    
        if (timeElapsedSeconds >= 1) {
            const bytesSinceLastCalc = fileData.receivedSize - fileData.lastSpeedCalcBytes;
            const speed = timeElapsedSeconds > 0 ? (bytesSinceLastCalc / timeElapsedSeconds) : 0;
            if (speedSpan) speedSpan.textContent = formatSpeed(speed);
            if (receivedSizeSpan) receivedSizeSpan.textContent = formatFileSize(fileData.receivedSize);
            fileData.lastSpeedCalcBytes = fileData.receivedSize;
            fileData.lastSpeedCalcTime = currentTime;
        }
    
        if (currentConnection && currentConnection.open && fileData.totalSize > 0) {
            const currentFlooredPercentage = Math.floor(overallProgress);
            if (currentFlooredPercentage > fileData.lastReportedPercentage || (currentFlooredPercentage === 100 && fileData.lastReportedPercentage !== 100)) {
                if (currentFlooredPercentage <= 100) {
                    currentConnection.send({
                        type: 'receiver-progress', fileName: name,
                        percentage: currentFlooredPercentage, receivedBytes: fileData.receivedSize
                    });
                    fileData.lastReportedPercentage = currentFlooredPercentage;
                }
            }
        }
    
        if ((isLast || fileData.senderFinishedSending) && fileData.receivedSize >= fileData.totalSize && fileData.totalSize > 0) {
            if (fileData.completed) return; 
            
            const expectedTotalChunks = fileData.totalChunksCount > 0 ? fileData.totalChunksCount : Math.ceil(fileData.totalSize / CHUNK_SIZE);
            let allChunksPresent = true;
            for(let i = 0; i < expectedTotalChunks; i++) { 
                if(!fileData.chunks[i]) {
                    allChunksPresent = false;
                    console.warn(`[RECEIVER DEBUG] Missing chunk ${i} for file ${name} at completion check.`);
                }
            }

            if (!allChunksPresent && (isLast || fileData.senderFinishedSending)) {
                console.error(`[RECEIVER DEBUG] Critical: File ${name} marked for completion, but not all chunks are present. Aborting assembly.`);
                showMessage('receive', `Error assembling file '${escapedFileName}'. Missing chunk data.`, 'error');
                const statusP_err = fileItemElement.querySelector('.file-status-text');
                if(statusP_err) statusP_err.innerHTML = `<span class="text-red-500 font-medium">Assembly Error - Data Missing</span>`;
                fileData.completed = false; 
                fileData.cancelled = true; 
                if (name === currentDownloadingFileReceiver) currentDownloadingFileReceiver = null;
                processReceiverDownloadQueue();
                return;
            }

            fileData.completed = true; 
            console.log(`[RECEIVER DEBUG] Conditions met for completing ${name}. Assembling file.`);
            
            const assembledChunks = [];
            for(let i = 0; i < expectedTotalChunks; i++){ 
                if(fileData.chunks[i]){
                    assembledChunks.push(fileData.chunks[i]);
                } else {
                    console.error(`[RECEIVER DEBUG] Critical assembly error: Missing chunk ${i} for ${name} during final assembly loop.`);
                    showMessage('receive', `Error assembling file '${escapedFileName}'. Missing data (loop).`, 'error');
                    const statusP_err = fileItemElement.querySelector('.file-status-text');
                    if(statusP_err) statusP_err.innerHTML = `<span class="text-red-500 font-medium">Assembly Error - Missing (Loop)</span>`;
                    if (name === currentDownloadingFileReceiver) currentDownloadingFileReceiver = null;
                    processReceiverDownloadQueue();
                    return; 
                }
            }
    
            if(receivedSizeSpan) receivedSizeSpan.textContent = formatFileSize(fileData.receivedSize);
            if(speedSpan) {
                const finalTotalTimeSeconds = (Date.now() - fileData.initialRequestTime) / 1000;
                const overallSpeed = finalTotalTimeSeconds > 0 ? fileData.receivedSize / finalTotalTimeSeconds : 0;
                speedSpan.textContent = `Avg. ${formatSpeed(overallSpeed)}`;
            }

            const completeFileBlob = new Blob(assembledChunks, { type: fileData.fileType || 'application/octet-stream' });
            triggerDownload(completeFileBlob, name);
            showMessage('receive', `'${escapedFileName}' downloaded successfully!`, 'success');
            
            const statusP = fileItemElement.querySelector('.file-status-text');
            if(progressBar) progressBar.classList.add('completed');
            if(statusP) statusP.innerHTML = `<span class="text-green-600 font-medium">Downloaded! (${formatFileSize(fileData.totalSize)})</span>`;
            
            const downloadButton = fileItemElement.querySelector('.download-btn');
            const cancelButton = fileItemElement.querySelector('.cancel-btn');
            if(downloadButton) { 
                downloadButton.innerHTML = '<i class="fas fa-check-circle"></i> Done';
                downloadButton.classList.replace('bg-green-500', 'bg-gray-400');
                downloadButton.classList.replace('hover:bg-green-600', 'hover:bg-gray-400');
                downloadButton.style.display = 'inline-flex'; 
                downloadButton.disabled = true; 
            }
            if (cancelButton) cancelButton.style.display = 'none';

            if (currentConnection && currentConnection.open && fileData.lastReportedPercentage !== 100) {
                currentConnection.send({ type: 'receiver-progress', fileName: name, percentage: 100, receivedBytes: fileData.receivedSize });
            }
    
            if (name === currentDownloadingFileReceiver) { 
                currentDownloadingFileReceiver = null;
            }
            console.log(`[RECEIVER DEBUG] File ${name} completed. Calling processReceiverDownloadQueue.`);
            processReceiverDownloadQueue(); 
        } else if ((isLast || fileData.senderFinishedSending) && fileData.receivedSize < fileData.totalSize) {
            console.warn(`[RECEIVER DEBUG] End signal for ${name}, but receivedSize (${fileData.receivedSize}) < totalSize (${fileData.totalSize}).`);
        }
    }

    function triggerDownload(blob, fileName) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a); 
        a.click();
        document.body.removeChild(a); 
        URL.revokeObjectURL(url); 
    }

    window.addEventListener('load', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const shareIdFromUrl = urlParams.get('shareId'); 
        if (shareIdFromUrl) {
            const receiveTabLink = Array.from(tabLinks).find(link => link.getAttribute('onclick').includes('receive-tab'));
            if (receiveTabLink) openTab({ currentTarget: receiveTabLink }, 'receive-tab');
            if(senderIdInput) senderIdInput.value = shareIdFromUrl;
            showMessage('receive', `Sender ID detected from URL. Click 'Connect to Sender' to proceed.`, 'info');
        }
    });

    window.addEventListener('beforeunload', () => {
        if (peer) { peer.destroy(); peer = null; }
    });

    </script>
</body>
</html>
